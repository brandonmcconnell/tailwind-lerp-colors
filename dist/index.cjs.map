{"version":3,"file":"index.cjs","sources":["../index.ts"],"sourcesContent":["import chroma, { InterpolationMode } from 'chroma-js';\nimport builtInColors from 'tailwindcss/colors';\n\nfunction keys<T extends object>(obj: T): (keyof T)[] {\n  return Object.keys(obj) as (keyof T)[];\n}\n\nfunction entries<T extends object>(obj: T): [keyof T, T[keyof T]][] {\n  return Object.entries(obj) as [keyof T, T[keyof T]][];\n}\n\nfunction hasOwn<T extends object>(obj: T, key: keyof T): key is keyof T {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\n// valid color modes for chroma-js\nexport const validColorModes = [\n  'rgb',\n  'lab',\n  'lch',\n  'lrgb',\n  'hcl',\n  'num',\n  'hcg',\n  'oklch',\n  'hsi',\n  'hsl',\n  'hsv',\n  'oklab',\n] as const;\n\n// types for tailwind-lerp-colors\ntype NumericObjKey = number | `${number}`;\ntype Shades = Record<NumericObjKey, string>;\ntype Colors = Record<string, Shades | string>;\ntype ColorMode = (typeof validColorModes)[number];\ntype Options = {\n  includeBase?: boolean;\n  includeLegacy?: boolean;\n  lerpEnds?: boolean;\n  interval?: number;\n  mode?: ColorMode;\n};\ntype OptionName = keyof Options;\ntype Option<T extends OptionName> = Options[T];\ntype SingularOptions = Pick<Options, 'lerpEnds' | 'interval' | 'mode'>;\n\n// default options for tailwind-lerp-colors -> lerpColor\nconst defaultSingleOptions: Required<SingularOptions> = {\n  lerpEnds: true,\n  interval: 25,\n  mode: 'lrgb',\n};\n\n// default options for tailwind-lerp-colors -> lerpColors\nconst defaultOptions = {\n  includeBase: true,\n  includeLegacy: false,\n  ...defaultSingleOptions,\n};\n\nconst isOptionInvalid = <T extends OptionName>(options: Options, optionName: T, test: (k: Option<T>) => boolean) => {\n  return options && hasOwn(options, optionName) && !test(options[optionName]);\n};\n\nconst throwError = (message: string) => {\n  throw new Error(message);\n};\n\nconst isValidShade = (shades: Shades) => {\n  if (\n    // undefined or null\n    shades == null ||\n    // check if shades is an object\n    typeof shades !== 'object' ||\n    // check if shades is an array\n    Array.isArray(shades) ||\n    shades.toString() !== '[object Object]' ||\n    !keys(shades).every((key) => {\n      return !isNaN(+key);\n    })\n  ) {\n    return false;\n  }\n  return true;\n};\n\nexport const lerpColor = (shades: Shades, options: SingularOptions = {}) => {\n  // validate lerpEnds\n  if (isOptionInvalid(options, 'lerpEnds', (v) => typeof v === 'boolean'))\n    throwError('tailwind-lerp-colors option `lerpEnds` must be a boolean.');\n\n  // validate interval\n  if (isOptionInvalid(options, 'interval', (v) => Number.isInteger(v) && typeof v === 'number' && v > 0))\n    throwError('tailwind-lerp-colors option `interval` must be a positive integer greater than 0.');\n\n  // validate mode\n  if (isOptionInvalid(options, 'mode', (v) => typeof v === 'string' && validColorModes.includes(v)))\n    throwError(\n      `tailwind-lerp-colors option \\`mode\\` must be one of the following values: ${validColorModes.join(', ')}.`\n    );\n\n  if (!isValidShade(shades))\n    throwError(\n      'tailwind-lerp-colors object `shades` must be an object with numeric keys.\\n\\nvalue used: ' +\n        JSON.stringify(shades, null, 2)\n    );\n  const { lerpEnds, interval, mode } = {\n    ...defaultSingleOptions,\n    ...(options ?? {}),\n  };\n\n  const sortByNumericFirstIndex = ([numericKeyA]: [number, string], [numericKeyB]: [number, string]) => {\n    return numericKeyA - numericKeyB;\n  };\n\n  const shadesArray = entries(shades)\n    .map(([numericStringKey, color]) => {\n      return [Number(numericStringKey), color] as [number, string];\n    })\n    .sort(sortByNumericFirstIndex);\n\n  if (lerpEnds) {\n    shadesArray.unshift([0, '#ffffff']);\n    shadesArray.push([1000, '#000000']);\n  }\n  const finalShades = [...shadesArray];\n  for (let i = 0; i < shadesArray.length - 1; i++) {\n    const [shade, color] = shadesArray[i];\n    const [nextShade, nextColor] = shadesArray[i + 1];\n\n    // check to make sure both shades being compared\n    // are evenly divisible by the set interval\n    const interpolations = (nextShade - shade) / interval - 1;\n    if (interpolations <= 0 || !Number.isInteger(interpolations)) continue;\n\n    const scale = chroma.scale([color, nextColor]).mode(mode as InterpolationMode);\n    const getColorAt = (percent: number) => scale(percent).hex();\n    for (let run = 1; run <= interpolations; run++) {\n      const percent = run / (interpolations + 1);\n      finalShades.push([shade + interval * run, getColorAt(percent)]);\n    }\n  }\n  finalShades.sort(sortByNumericFirstIndex);\n\n  return Object.fromEntries(finalShades);\n};\n\nexport const lerpColors = (colorsObj: Colors = {}, options: Options = {}) => {\n  // validate includeBase\n  if (isOptionInvalid(options, 'includeBase', (v) => typeof v === 'boolean'))\n    throwError('tailwind-lerp-colors option `includeBase` must be a boolean.');\n\n  // validate includeLegacy\n  if (isOptionInvalid(options, 'includeLegacy', (v) => typeof v === 'boolean'))\n    throwError('tailwind-lerp-colors option `includeLegacy` must be a boolean.');\n\n  const legacyNames = ['lightBlue', 'warmGray', 'trueGray', 'coolGray', 'blueGray'];\n\n  const { includeBase, includeLegacy, lerpEnds, interval, mode } = {\n    ...defaultOptions,\n    ...options,\n  };\n  const baseColors: Colors = {};\n  if (includeBase) {\n    const builtInColorKeys = keys(builtInColors);\n    for (const key of builtInColorKeys) {\n      if (!legacyNames.includes(key) || includeLegacy) {\n        baseColors[key] = builtInColors[key];\n      }\n    }\n  }\n\n  const initialColors = entries({\n    ...baseColors,\n    ...colorsObj,\n  });\n\n  const finalColors: Colors = {};\n\n  for (const [name, shades] of initialColors) {\n    finalColors[`${name}`] = shades;\n\n    // some shades from tailwind base colors are not objects;\n    // skip those\n    if (!isValidShade(shades)) {\n      continue;\n    }\n\n    finalColors[name] = lerpColor(shades, { lerpEnds, interval, mode });\n  }\n\n  return finalColors;\n};\n\nexport type {\n  Shades as LerpColorsShades,\n  Colors as LerpColorsColors,\n  ColorMode as LerpColorsColorMode,\n  Options as LerpColorsOptions,\n  OptionName as LerpColorsOptionName,\n  Option as LerpColorsOption,\n  SingularOptions as LerpColorsSingularOptions,\n};\n\nmodule.exports = {\n  validColorModes,\n  lerpColor,\n  lerpColors,\n};\n"],"names":["keys","obj","Object","entries","validColorModes","defaultSingleOptions","lerpEnds","interval","mode","defaultOptions","_extends","includeBase","includeLegacy","isOptionInvalid","options","optionName","test","prototype","hasOwnProperty","call","throwError","message","Error","isValidShade","shades","Array","isArray","toString","every","key","isNaN","lerpColor","_options","v","Number","isInteger","includes","join","JSON","stringify","_defaultSingleOptions","sortByNumericFirstIndex","_ref","_ref2","shadesArray","map","_ref3","color","sort","unshift","push","finalShades","concat","_loop","percent","_shadesArray$i","i","shade","_shadesArray","nextColor","interpolations","scale","chroma","run","hex","length","fromEntries","lerpColors","colorsObj","legacyNames","_defaultOptions$optio","baseColors","_step","_iterator","_createForOfIteratorHelperLoose","builtInColors","done","value","_step2","finalColors","_iterator2","_step2$value","name","module","exports"],"mappings":"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"}