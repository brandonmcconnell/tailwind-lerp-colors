{"version":3,"file":"index.modern.js","sources":["../index.ts"],"sourcesContent":["import chroma, { InterpolationMode } from 'chroma-js';\nimport builtInColors from 'tailwindcss/colors';\n\nfunction keys<T extends object>(obj: T): (keyof T)[] {\n  return Object.keys(obj) as (keyof T)[];\n}\n\nfunction entries<T extends object>(obj: T): [keyof T, T[keyof T]][] {\n  return Object.entries(obj) as [keyof T, T[keyof T]][];\n}\n\nfunction hasOwn<T extends object>(obj: T, key: keyof T): key is keyof T {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\n// valid color modes for chroma-js\nexport const validColorModes = [\n  'rgb',\n  'lab',\n  'lch',\n  'lrgb',\n  'hcl',\n  'num',\n  'hcg',\n  'oklch',\n  'hsi',\n  'hsl',\n  'hsv',\n  'oklab',\n] as const;\n\n// types for tailwind-lerp-colors\ntype NumericObjKey = number | `${number}`;\ntype Shades = Record<NumericObjKey, string>;\ntype Colors = Record<string, Shades | string>;\ntype ColorMode = (typeof validColorModes)[number];\ntype Options = {\n  includeBase?: boolean;\n  includeLegacy?: boolean;\n  lerpEnds?: boolean;\n  interval?: number;\n  mode?: ColorMode;\n};\ntype OptionName = keyof Options;\ntype Option<T extends OptionName> = Options[T];\ntype SingularOptions = Pick<Options, 'lerpEnds' | 'interval' | 'mode'>;\n\n// default options for tailwind-lerp-colors -> lerpColor\nconst defaultSingleOptions: Required<SingularOptions> = {\n  lerpEnds: true,\n  interval: 25,\n  mode: 'lrgb',\n};\n\n// default options for tailwind-lerp-colors -> lerpColors\nconst defaultOptions = {\n  includeBase: true,\n  includeLegacy: false,\n  ...defaultSingleOptions,\n};\n\nconst isOptionInvalid = <T extends OptionName>(options: Options, optionName: T, test: (k: Option<T>) => boolean) => {\n  return options && hasOwn(options, optionName) && !test(options[optionName]);\n};\n\nconst throwError = (message: string) => {\n  throw new Error(message);\n};\n\nconst isValidShade = (shades: Shades) => {\n  if (\n    // undefined or null\n    shades == null ||\n    // check if shades is an object\n    typeof shades !== 'object' ||\n    // check if shades is an array\n    Array.isArray(shades) ||\n    shades.toString() !== '[object Object]' ||\n    !keys(shades).every((key) => {\n      return !isNaN(+key);\n    })\n  ) {\n    return false;\n  }\n  return true;\n};\n\nexport const lerpColor = (shades: Shades, options: SingularOptions = {}) => {\n  // validate lerpEnds\n  if (isOptionInvalid(options, 'lerpEnds', (v) => typeof v === 'boolean'))\n    throwError('tailwind-lerp-colors option `lerpEnds` must be a boolean.');\n\n  // validate interval\n  if (isOptionInvalid(options, 'interval', (v) => Number.isInteger(v) && typeof v === 'number' && v > 0))\n    throwError('tailwind-lerp-colors option `interval` must be a positive integer greater than 0.');\n\n  // validate mode\n  if (isOptionInvalid(options, 'mode', (v) => typeof v === 'string' && validColorModes.includes(v)))\n    throwError(\n      `tailwind-lerp-colors option \\`mode\\` must be one of the following values: ${validColorModes.join(', ')}.`\n    );\n\n  if (!isValidShade(shades))\n    throwError(\n      'tailwind-lerp-colors object `shades` must be an object with numeric keys.\\n\\nvalue used: ' +\n        JSON.stringify(shades, null, 2)\n    );\n  const { lerpEnds, interval, mode } = {\n    ...defaultSingleOptions,\n    ...(options ?? {}),\n  };\n\n  const sortByNumericFirstIndex = ([numericKeyA]: [number, string], [numericKeyB]: [number, string]) => {\n    return numericKeyA - numericKeyB;\n  };\n\n  const shadesArray = entries(shades)\n    .map(([numericStringKey, color]) => {\n      return [Number(numericStringKey), color] as [number, string];\n    })\n    .sort(sortByNumericFirstIndex);\n\n  if (lerpEnds) {\n    shadesArray.unshift([0, '#ffffff']);\n    shadesArray.push([1000, '#000000']);\n  }\n  const finalShades = [...shadesArray];\n  for (let i = 0; i < shadesArray.length - 1; i++) {\n    const [shade, color] = shadesArray[i];\n    const [nextShade, nextColor] = shadesArray[i + 1];\n\n    // check to make sure both shades being compared\n    // are evenly divisible by the set interval\n    const interpolations = (nextShade - shade) / interval - 1;\n    if (interpolations <= 0 || !Number.isInteger(interpolations)) continue;\n\n    const scale = chroma.scale([color, nextColor]).mode(mode as InterpolationMode);\n    const getColorAt = (percent: number) => scale(percent).hex();\n    for (let run = 1; run <= interpolations; run++) {\n      const percent = run / (interpolations + 1);\n      finalShades.push([shade + interval * run, getColorAt(percent)]);\n    }\n  }\n  finalShades.sort(sortByNumericFirstIndex);\n\n  return Object.fromEntries(finalShades);\n};\n\nexport const lerpColors = (colorsObj: Colors = {}, options: Options = {}) => {\n  // validate includeBase\n  if (isOptionInvalid(options, 'includeBase', (v) => typeof v === 'boolean'))\n    throwError('tailwind-lerp-colors option `includeBase` must be a boolean.');\n\n  // validate includeLegacy\n  if (isOptionInvalid(options, 'includeLegacy', (v) => typeof v === 'boolean'))\n    throwError('tailwind-lerp-colors option `includeLegacy` must be a boolean.');\n\n  const legacyNames = ['lightBlue', 'warmGray', 'trueGray', 'coolGray', 'blueGray'];\n\n  const { includeBase, includeLegacy, lerpEnds, interval, mode } = {\n    ...defaultOptions,\n    ...options,\n  };\n  const baseColors: Colors = {};\n  if (includeBase) {\n    const builtInColorKeys = keys(builtInColors);\n    for (const key of builtInColorKeys) {\n      if (!legacyNames.includes(key) || includeLegacy) {\n        baseColors[key] = builtInColors[key];\n      }\n    }\n  }\n\n  const initialColors = entries({\n    ...baseColors,\n    ...colorsObj,\n  });\n\n  const finalColors: Colors = {};\n\n  for (const [name, shades] of initialColors) {\n    finalColors[`${name}`] = shades;\n\n    // some shades from tailwind base colors are not objects;\n    // skip those\n    if (!isValidShade(shades)) {\n      continue;\n    }\n\n    finalColors[name] = lerpColor(shades, { lerpEnds, interval, mode });\n  }\n\n  return finalColors;\n};\n\nexport type {\n  Shades as LerpColorsShades,\n  Colors as LerpColorsColors,\n  ColorMode as LerpColorsColorMode,\n  Options as LerpColorsOptions,\n  OptionName as LerpColorsOptionName,\n  Option as LerpColorsOption,\n  SingularOptions as LerpColorsSingularOptions,\n};\n"],"names":["keys","obj","Object","entries","validColorModes","defaultSingleOptions","lerpEnds","interval","mode","defaultOptions","_extends","includeBase","includeLegacy","isOptionInvalid","options","optionName","test","prototype","hasOwnProperty","call","throwError","message","Error","isValidShade","shades","Array","isArray","toString","every","key","isNaN","lerpColor","v","Number","isInteger","includes","join","JSON","stringify","sortByNumericFirstIndex","numericKeyA","numericKeyB","shadesArray","map","numericStringKey","color","sort","unshift","push","finalShades","i","length","shade","nextShade","nextColor","interpolations","scale","chroma","getColorAt","percent","hex","run","fromEntries","lerpColors","colorsObj","legacyNames","baseColors","builtInColorKeys","builtInColors","initialColors","finalColors","name"],"mappings":"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"}